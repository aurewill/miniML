(* 
                         CS 51 Final Project
                    MiniML -- Read-Eval-Print Loop
 *)

module Ev = Evaluation ;;
module MP = Miniml_parse ;;
module ML = Miniml_lex ;;
module Ex = Expr ;;

(* Exception for evaluator runtime, generated by a runtime error in
   the interpreter *)
exception EvalError of string ;;

open Printf ;;

(* str_to_exp str -- Returns the expression specified by `str` using
   the MiniML parser. *)
let str_to_exp (str: string) : Ex.expr =
  let lexbuf = Lexing.from_string str in
  let exp = MP.input ML.token lexbuf in
  exp ;;

(* repl () -- Read-eval-print loop for MiniML, which prompts for and
   evaluates MiniML expressions, printing the resulting value. Exits
   the loop and terminates upon reading an end-of-file
   (control-d). *)
let repl () =
  (* lexical analyzer buffer from stdin *)
  let lexbuf = Lexing.from_channel stdin in
  (* set up the initial environment *)
  let env = Ev.Env.empty () in

  (* the main LOOP *)
  while true do
    (try
        (* prompt *)
        printf "<== %!";
        
        (* READ and parse an expression from the input *)
        let exp = MP.input ML.token lexbuf in 
        printf "A ==> %s\n" (Ex.exp_to_abstract_string exp);

        (try
          (* EVALuate it under substitution semantics *)
          let res_s = Ev.eval_s exp env in
          
          (* PRINT the result; in this initial version, the trivial
            evaluator just returns the expression unchanged as an
            element of the `Env.value` type (found in `expr.ml`), so we
            just extract the expression back out and print it *)
          match res_s with
          | Ev.Env.Val res -> printf "S ==> %s\n" (Ex.exp_to_concrete_string res)
          | _ -> raise (EvalError "Debug: this case should not match after eval")
        with
        | Ev.EvalError msg -> printf "S ==> xx> evaluation error: %s\n" msg
        | Ev.EvalException -> printf "S ==> xx> evaluation exception\n");

        (try
          (* EVALuate it under dynamic env semantics *)
          let res_d = Ev.eval_d exp env in
          
          (* PRINT the result; in this initial version, the trivial
            evaluator just returns the expression unchanged as an
            element of the `Env.value` type (found in `expr.ml`), so we
            just extract the expression back out and print it *)
          match res_d with
          | Ev.Env.Val res -> printf "D ==> %s\n" (Ex.exp_to_concrete_string res)
          | _ -> raise (EvalError "Debug: this case should not match after eval")
        with
        | Ev.EvalError msg -> printf "D ==> xx> evaluation error: %s\n" msg
        | Ev.EvalException -> printf "D ==> xx> evaluation exception\n");

        (try
          (* EVALuate it under lexical env semantics *)
          let res_l = Ev.eval_l exp env in
          
          (* PRINT the result; in this initial version, the trivial
            evaluator just returns the expression unchanged as an
            element of the `Env.value` type (found in `expr.ml`), so we
            just extract the expression back out and print it *)
          match res_l with
          | Ev.Env.Val res -> printf "L ==> %s\n" (Ex.exp_to_concrete_string res)
          | Ev.Env.Closure (res, env_res) -> 
            printf "L ==> %s where %s\n" (Ex.exp_to_concrete_string res)
                                         (Ev.Env.env_to_string env_res)
        with
        | Ev.EvalError msg -> printf "L ==> xx> evaluation error: %s\n" msg
        | Ev.EvalException -> printf "L ==> xx> evaluation exception\n");

      with
      | MP.Error -> printf "xx> parse error\n"
      | End_of_file -> printf "Goodbye.\n"; exit 0
    );
    flush stdout
  done
;;
        
(* Run REPL if called from command line *)

try
  let _ = Str.search_forward (Str.regexp "miniml\\.\\(byte\\|native\\|bc\\|exe\\)")
                             (Sys.argv.(0)) 0 in
  repl ()
with Not_found -> () ;;
